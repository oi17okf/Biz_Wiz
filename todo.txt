TYPES OF WINDOWS TO IMPLEMENT
- Key 0. Settings Panel. i.e open a new file for reading. Only 1 file at a time. (this should not be used that much, since it will default to a hardcoded file/run param.
- Key 1.View (almost) raw data. See everything contained in the read data file. How many traces, How many events. Event per trace. All trace keys, all event keys. 
	This might not be super useful but good for generating knowledge about the file type for me. It seems that concept:name and timestamp are the most relevant keys.
- Key 2. Interactable node graph. Allows for creating of nodes, connections. Sidebar with allowable actions. (all)Graph should be scrollable. Most graphs should reuse functionality.
- Key 3. View text Data in how it interacts with the constructed node graph. i.e how many traces passes, which ones don't.
- Key 4. View singular traces in node form (option to underlay the expected graph). Allows for viewing of all traces, but focus should be on 'bad traces'.
- Key 5. View difference from expected value in node form. Allows for viewing of all traces, but focus should be on 'bad traces'.
	All node graphs should be in the format of logical time + connection time. Displaying a number + color on each connection with a arrow giving direction.
	It should also match up with a linear wallclock timeline to the left. 
	This is nothing new, but is good to implement to get confortable. After, time to experiment with more things.
- Key 6. 



Todo:
	Convert 2d to 3d.


Main idea:
	Just make a '3d world' that displays a bunch of 'displays' that gives information in different ways regarding an event log.
	To measure if this is useful, use a case study of someone being dropped in to the program for X minutes, then see what they have learned about the log. Also ask what parts of the program was most useful in generating understanding.




Om man byter action sätt:

1. Skapa enum Action kategori.
2. Fyll i sträng-översätning
3. Skapa struct gällande den actionen som innehåller allt som behövs för den.
4. Skapa funktion som utifrån det som behövs bygger structen.
5. Skapa funktion som helt utifrån den nyskapade structen gör det som Actionen ska göra.
6. Lägg till case i do_action som kallar functionen
7. Skapa Action och lägg till på godtagligt ställe (t.ex i collision check). 
	Men spelar inte så stor roll vart man lägger till.
	Bara det blir smidigt...

3 + 4 + 5 Går att göra först, sen koppla ihop allt som behövs efter.

För att göra detta så måste man även byta ut action_list till std::vector<action*>, då kan 4. bara kalla new, 
	sen tar clear_action_list hand om delete.

Detta borde gå right? Blir ju lite mer kod att skriva just nu men gör ju allt mkt simplare i längden?

Borde någ lägga till state i main-menu? &&&&&&&&&&&&&&&&